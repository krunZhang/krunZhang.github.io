<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java中的类型、值和变量之基本类型</title>
      <link href="/2018/03/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <content type="html"><![CDATA[<h2 id="Java-中的类型、值和变量-之-基本类型"><a href="#Java-中的类型、值和变量-之-基本类型" class="headerlink" title="Java 中的类型、值和变量 之 基本类型"></a>Java 中的类型、值和变量 之 基本类型</h2><p>众所周知，<em>Java</em>是一门静态类型的语言，这意味着所有的变量和表达式的类型会在编译时确定。同时，<em>Java</em> 还是一门强类型的语言，因此变量的值或表达式的结果的类型都会受到限制（比如一个声明为 <code>String</code> 的变量不的值不可能是一个数值 <code>1</code>），类型之间的运算也会被限制，这有助于在编译时发现绝大多数的错误。</p><p>在 <em>Java</em>中存在两种类型：基本类型和引用类型。</p><pre><code class="text">PrimitiveType:    {Annotation} NumericType    {Annotation} booleanNumericType:    IntegralType    FloatingPointTypeIntegralType:    (one of)    byte short int long charFloatingPointType:    (one of)    float double</code></pre><blockquote><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2" target="_blank" rel="noopener">Java Language Specification (Java SE 8 Edition)  §4.2 Primitive Types and Values</a></p></blockquote><p><strong>值得注意的是，基本类型的值的状态不会被共享。</strong></p><p>比如下面这个例子:</p><pre><code class="java">int i = 0;int j = i;i += 1;System.out.println(j);AtomicInteger i = new AtomicInteger(0);AtomicInteger j = i;i.addAndGet(1);System.out.println(j);</code></pre><p>上述代码将输出:</p><pre><code class="text">01</code></pre><h3 id="整数类型和它们的值"><a href="#整数类型和它们的值" class="headerlink" title="整数类型和它们的值"></a>整数类型和它们的值</h3><p>整数类型 (<em>IntegralType</em>) 包含了以下五种类型:</p><table><thead><tr><th>类型</th><th>长度 / 位 (bit)</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>有符号 8</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>有符号 16</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>有符号 32</td><td>-214783648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>有符号 64</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>无符号 16</td><td><code>\u0000</code> ~ <code>\uffff</code> 等价于 0 ~ 65535</td></tr></tbody></table><h4 id="整数类型所支持的运算"><a href="#整数类型所支持的运算" class="headerlink" title="整数类型所支持的运算"></a>整数类型所支持的运算</h4><ul><li>比较运算符: <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 、<code>==</code>、<code>!=</code> ，其结果为 <code>boolean</code> 类型；</li><li>数值运算符:<ul><li>一元运算符:  <code>+</code> 、<code>-</code></li><li>乘法运算符:  <code>*</code>、<code>/</code>、<code>%</code></li><li>加法运算符:  <code>+</code> 、<code>-</code></li><li>自增运算符:  <code>++</code>, 分为前缀自增 (<code>++i</code>) 和后缀自增 (<code>i++</code>)</li><li>自减运算符:  <code>--</code>, 分为前缀自减 (<code>--i</code>) 和后缀自减 (<code>i--</code>)</li><li>位移运算符:<ul><li>左移运算符:  <code>&lt;&lt;</code></li><li>有符号右移:  <code>&gt;&gt;</code></li><li>无符号右移:  <code>&gt;&gt;&gt;</code></li></ul></li><li>按位互补运算符:  <code>~</code></li><li>整数按位运算符:  <code>&amp;</code>、<code>^</code>、<code>|</code></li></ul></li><li>条件运算符: <code>? :</code></li><li>类型转换运算符:  <code>cast</code></li><li>字符串拼接运算符:  <code>+</code></li></ul><p>这里面加号出现了好几次，包括 <em>一元运算符</em>、<em>加法运算符</em>、<em>自增运算符</em>、<em>字符串拼接运算符</em>，后三者运算符就如它们的字面意思般，很好理解。</p><p>那么 <em>一元运算符</em> 是什么意思呢？</p><p>让我们来看看下面这份代码:</p><pre><code class="java">static void is (short i) {    System.out.println(&quot;short&quot;);}static void is (int i) {    System.out.println(&quot;int&quot;);}static void is (long i) {    System.out.println(&quot;long&quot;);}static void main (String[] args) {    short i = 5;    int j = 10;    is(i);    is(+i);    is(-i);    is(j);    is(+j);    is(-j);}</code></pre><p>上述代码将输出:</p><pre><code class="text">shortintintintintint</code></pre><p>很显然，第 17~19 行的调用执行的是参数类型为 <code>int</code> 的方法，然而第 20~21 行的调用执行的并不是参数类型为 <code>long</code> 的方法。</p><p>我在 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.3" target="_blank" rel="noopener">JSL  § 15.15.3 Unary Plus Operator +</a> 中并未看出一元运算符的具体影响，根据实验结果只能推测一元运算符会将低于 <code>int</code> 的数值类型提升到 <code>int</code> 类型 (你可以声明一个 <code>byte h = 0</code>，<code>is(+h)</code> 仍然会调用参数类型为 <code>int</code> 的方法)，而且对于 <code>+</code> 和 <code>-</code> 都是提升类型的作用，并不是直觉意义上的一个升一个降。</p><p>关于这个 <em>一元运算符</em>  的用法其实并不是很多，有下列几种：</p><pre><code class="java">// 如果方法接受的是 int 类型的话，仅仅用来明确这是个正数还是负数。func(+1);func(-1);// 输出字符的代码值时的小技巧// 因为字符类型 char 是低于 int 的整数类型System.out.println(+&#39;c&#39;); // 99</code></pre><h4 id="整数运算的溢出和可能引发的异常"><a href="#整数运算的溢出和可能引发的异常" class="headerlink" title="整数运算的溢出和可能引发的异常"></a>整数运算的溢出和可能引发的异常</h4><p>对于移位运算符以外的整数运算而言，如果两个操作数中至少有一个 <code>long</code> ，那么这次运算将会按 64位精度进行计算，并且其计算结果也是 <code>long</code> 类型，此时如果另一个操作数不是 <code>long</code>，那么会将它提升到 <code>long</code> 类型再计算；如果两个操作数都不是 <code>long</code>，那么会按 32位精度进行计算，并且计算结果为 <code>int</code>，如果任何一个操作数不是 <code>int</code>， 那么都将提升到 <code>int</code> 类型后再计算。</p><p>整数运算符会在以下情况抛出异常：</p><ul><li>涉及到对引用类型拆箱时，如果是空引用，那么会抛出 <code>NullPointerException</code>；</li><li>如果右操作数为零，那么整数除法运算符和整数取余运算符都会抛出 <code>ArithmeticException</code>；</li><li>在自增和自减的时候，如果涉及到拆箱装箱且内存不足，会抛出 <code>OutOfMemoryError</code></li></ul><p>来看看规范中给出的示例代码:</p><pre><code class="java">class Test {    public static void main (String[] args) {        int i = 1000000;        System.out.println(i * i);        long l = i;        System.out.println(l * l);        System.out.println(20296 / (l - i));    }}</code></pre><p>上述代码将输出:</p><pre><code class="text">-7273799681000000000000ArithmeticException</code></pre><p>对于 <code>int</code> 来说，1000000^2 太大了，而由于之前的运算规则，<code>i * i</code> 只能保存结果的低32位，十进制下也就是 <code>-727379968</code>。</p><h3 id="浮点类型和它们的值"><a href="#浮点类型和它们的值" class="headerlink" title="浮点类型和它们的值"></a>浮点类型和它们的值</h3><p><em>Java</em> 中的浮点类型遵循 <code>IEEE 754</code> 标准的定义。</p><blockquote><p><a href="https://www.wikiwand.com/en/IEEE_754-1985" target="_blank" rel="noopener">IEEE 754-1985 - Wikiwand</a></p><p><a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin" target="_blank" rel="noopener">IEEE 754_百度百科</a></p></blockquote><p>在 <em>IEEE 754</em> 标准中，定义了 32位精度的 <code>float</code>、64位精度的 <code>double</code>，还有正负数、正负0、正负无穷和特殊的 <code>NaN</code>。</p><p><code>NaN</code> 用于表示无效操作的结果，比如 <code>0.0 / 0.0</code>  (<code>0 / 0</code> 才适用整数运算中的 <em>右操作数为0</em> 的异常规则)，你可以在 <code>Float.NaN</code> 和 <code>Double.NaN</code> 中找到。</p><p><code>NaN</code> 是无序的，因此</p><ul><li><p>如果一次运算中一个或两个操作数都是 <code>NaN</code>，则比较运算符 (<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>) 都会返回 <code>false</code></p></li><li><p>如果操作数是 <code>NaN</code>，则相等运算符 (<code>==</code>) 返回 <code>false</code></p><p>如果 <code>x</code> 或 <code>y</code> 是 <code>NaN</code>，则 <code>(x &lt; y) == !(x &gt;= y)</code> 将返回 <code>false</code></p></li><li><p>如果任一操作数是 <code>NaN</code>, 则不等式运算符 <code>!=</code> 将返回 <code>true</code></p><p>当且仅当 <code>x</code> 为 <code>NaN</code> 时，<code>x != x</code> 将返回 <code>true</code></p></li></ul><h4 id="浮点类型所支持的运算"><a href="#浮点类型所支持的运算" class="headerlink" title="浮点类型所支持的运算"></a>浮点类型所支持的运算</h4><ul><li>比较运算符: <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 、<code>==</code>、<code>!=</code> ，其结果为 <code>boolean</code> 类型；</li><li>数值运算符:<ul><li>一元运算符:  <code>+</code> 、<code>-</code></li><li>乘法运算符:  <code>*</code>、<code>/</code>、<code>%</code></li><li>加法运算符:  <code>+</code> 、<code>-</code></li><li>自增运算符:  <code>++</code>, 分为前缀自增 (<code>++i</code>) 和后缀自增 (<code>i++</code>)</li><li>自减运算符:  <code>--</code>, 分为前缀自减 (<code>--i</code>) 和后缀自减 (<code>i--</code>)</li></ul></li><li>条件运算符: <code>? :</code></li><li>类型转换运算符:  <code>cast</code></li><li>字符串拼接运算符:  <code>+</code></li></ul><p>如果一次计算中，至少有一个二元运算符的操作数是浮点类型的，那么该操作就是一个浮点运算，即使另一个操作数是整数。</p><pre><code class="java">System.out.println(10 * 0.1); // 1.0</code></pre><p>对于浮点运算而言，如果两个操作数中至少有一个 <code>double</code>，那么这次运算将会按 64位精度进行计算，并且其计算结果也是 <code>double</code> 类型，此时如果另一个操作数不是 <code>double</code>，那么会将它提升到 <code>double</code> 类型再计算；如果两个操作数都不是 <code>double</code>，那么会按 32位精度进行计算，并且计算结果为 <code>float</code>，如果任何一个操作数不是 <code>float</code>， 那么都将提升到 <code>float</code> 类型后再计算。</p><h4 id="浮点运算的溢出和可能引发的异常"><a href="#浮点运算的溢出和可能引发的异常" class="headerlink" title="浮点运算的溢出和可能引发的异常"></a>浮点运算的溢出和可能引发的异常</h4><p>浮点运算有溢出 (<em>overflows</em>) 和下溢 (<em>underflows</em>)，其中溢出将产生有符号的无穷大，而下溢则产生一个非标准化 (<em>denormalized</em>) 的值或是一个有符号的0。</p><p>数学上无法确定结果的浮点运算将产生 <code>NaN</code>。</p><p>所有 <code>NaN</code> 参与的浮点运算都会产生 <code>NaN</code>。</p><p>在下列情况中，浮点运算会抛出异常：</p><ul><li>计算时需要拆箱，而又是个空引用时，会抛出 <code>NullPointerException</code>；</li><li>自增自减的情况下，如果需要拆箱装箱且内存不够时，会抛出 <code>OutOfMemoryError</code>。</li></ul><p>接下来看看规范中给出的示例代码:</p><pre><code class="java">class Test {    public static void main(String[] args) {        // 溢出        double d = 1e308;        System.out.print(&quot;溢出产生了无穷大: &quot;);        System.out.println(d + &quot;*10==&quot; + d*10);        // 渐变下溢 (gradual underflow)        d = 1e-305 * Math.PI;        System.out.print(&quot;渐变下溢: &quot; + d + &quot;\n   &quot;);        for (int i = 0; i &lt; 4; i++)            System.out.print(&quot; &quot; + (d /= 100000) + &quot;\n&quot;);        System.out.println();        // 产生 NaN        System.out.print(&quot;0.0/0.0 产生的不是数字: &quot;);        d = 0.0/0.0;        System.out.println(d);        // 产生不精确结果的四舍五入:        System.out.print(&quot;单精度下的不精确结果:&quot;);        for (int i = 0; i &lt; 100; i++) {            float z = 1.0f / i;            if (z * i != 1.0f)                System.out.print(&quot; &quot; + i);        }        System.out.println();        // 另一个产生不精确结果的四舍五入:        System.out.print(&quot;双精度下的不精确结果:&quot;);        for (int i = 0; i &lt; 100; i++) {            double z = 1.0 / i;            if (z * i != 1.0)                System.out.print(&quot; &quot; + i);        }        System.out.println();        // 转换到整数时发生的结果阶段:        System.out.print(&quot;强制转换到整数: &quot;);        d = 12345.6;        System.out.println((int)d + &quot; &quot; + (int)(-d));    }}</code></pre><p>上述代码将输出</p><pre><code class="text">溢出产生了无穷大: 1.0e + 308 * 10 == Infinity渐变下溢: 3.141592653589793E-305 3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0 0.0 / 0.0 产生的不是数字：NaN单精度下的不精确结果：0 41 47 55 61 82 83 94 97双精度下的不精确结果：0 49 98强制转换到整数：12345 -12345</code></pre><p>值得注意的是，在 <em>渐变下溢</em> 的例子中，我们可以看到精度逐渐丧失。</p><h3 id="布尔类型和它们的值"><a href="#布尔类型和它们的值" class="headerlink" title="布尔类型和它们的值"></a>布尔类型和它们的值</h3><p><code>boolean</code>类型表示两个逻辑量，<code>true</code> 和 <code>false</code>。</p><p>布尔运算符是：</p><ul><li>关系运算符 <code>==</code>和<code>!=</code> （</li><li>逻辑补足运算符 <code>!</code> </li><li>逻辑运算符<code>&amp;</code> ， <code>^</code> 和 <code>|</code> </li><li>条件运算符和条件运算符<code>&amp;&amp;</code>  和 <code>||</code> </li><li>条件运算符<code>? :</code> </li><li>字符串连接运算符 <code>+</code> ，当给定一个<code>String</code>操作数和一个 <code>boolean</code> 操作数时，它将把 <code>boolean</code> 操作符转换为一个<code>String</code> （ <code>&quot;true&quot;</code>或<code>&quot;false&quot;</code> ），然后产生一个新创建的<code>String</code>，其值为两个字符串的连接结果。</li></ul><p>布尔表达式决定了几种语句中的控制流：</p><ul><li><code>if</code> 语句</li><li><code>while</code> 语句</li><li><code>do</code> 语句</li><li><code>for</code> 语句</li></ul><p>一个<code>boolean</code>表达式还决定在 <code>? :</code> 运算符中使用哪个子表达式的值作为结果 。</p><p>只有<code>Boolean</code>表达式和<code>Boolean</code>表达式可以在控制流程语句中使用。</p><p>通过表达式 <code>x!=0</code> ，可以将整数或浮点表达式 <code>x</code> 转换为 <code>boolean</code> 值，这遵循了 <em>C</em> 语言约定，即任何非零值为<code>true</code> 。</p><p>通过表达式 <code>obj!=null</code> ，可以将对象引用 <code>obj</code> 转换为<code>boolean</code>值，这同样遵循了 <em>C</em> 语言约定（除<code>null</code>之外的任何引用为<code>true</code> 。</p><blockquote><p>参考资料: <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2" target="_blank" rel="noopener">Java Language Specification (Java SE 8 Edition) § 4.2  </a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你好，世界！</title>
      <link href="/2018/03/20/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81/"/>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java·关于一道面试题的思考</title>
      <link href="/2018/03/19/Java%C2%B7%E5%85%B3%E4%BA%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <content type="html"><![CDATA[<blockquote><p>文中的速度测试部分，时间是通过简单的 System.currentTimeMillis() 计算得到的，<br>又由于 Java 的特性，每次测试的结果都不一定相同，<br>对于低数量级的情况有 ± 20 的浮动，对于高数量级的情况有的能有 ± 1000 的浮动。</p><p>这道题本质上是个约瑟夫环问题，最佳解法在最下面，本文只是探究一下数组暴力和链表的表现差异。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>N 个人围成一圈，顺序排号。从第一个人开始报数（从1数到3），凡是到3的人退出圈子，问最后留下的是原来第几号。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><ul><li><p>2 个人时留下的是第二个；</p></li><li><p>3个人时留下的是第二个；</p></li><li><p>5个人时留下的是第四个；</p></li><li><p>12个人时留下的是第十个；</p></li><li><p>100，000个人时留下的是第92620个人。</p></li></ul><h3 id="机器环境"><a href="#机器环境" class="headerlink" title="机器环境"></a>机器环境</h3><p>CPU  Intel Xeon E3-1231 v3 @ 3.40GHz</p><p>RAM 16 GB</p><h1 id="暴力解决"><a href="#暴力解决" class="headerlink" title="暴力解决"></a>暴力解决</h1><p>虽然第一反应是用链表，但对于人数在1000以下的量级感觉数组也足以胜任，因此先用数组试试。</p><p>对于这种会 <em>退出</em> 的情况，数组显然不能像链表一样直接断开，因此采用标记法：</p><p>先生成一个长度为 N 的布尔型数组，用 <code>true</code> 填充。</p><p>报号时，对于报到 3 的位置，用 <code>false</code> 来标记该位置，下次循环如果遇到 <code>false</code> 则可以直接跳过。</p><p>那么等到数组内只剩一个 <code>true</code> 的时候，找到其位置，即是最后留下来的人的位置。</p><p>既然暴力，那干脆彻底一点：</p><pre><code class="java">    public static int findIndex(final int N) {        boolean[] map = new boolean[N];        Arrays.fill(map, true);        int walk = 1;         // 因为是站成一个圆，所以在遍历到最后时需要将下标重新指向 0           // count(map) 就是遍历整个数组计算还剩余的 true 的数量        for (int index = 0; count(map) &gt; 1; index = (index == N - 1) ? 0 : (index + 1)) {            // 对于 false 可以直接跳过，因为它们相当于不存在               if (! map[index]) continue;             // 报号时如果不是3 则继续找下一位;            if (walk++ != 3) continue;             // 如果是 3，则重置报号，并将当前位置的值改为 false            walk = 1;            map[index] = false;        }        return find(map);    }    // 因为是 count(map) == 1 的情况下才会调用这个方法，所以直接返回第一个 true 所在的位置即可    public static int find(boolean[] map) {        for (int i = 0; i &lt; map.length; i++) {            if (!map[i]) continue;            return i + 1;        }        return -1;    }    public static int count(boolean[] map) {        int count = 0;        for (boolean bool : map) {            count += bool ? 1 : 0;        }        return count;    }；</code></pre><p>对于这个解法，可以跑一下测试看看耗时：</p><table><thead><tr><th>N</th><th>time / ms</th></tr></thead><tbody><tr><td>100</td><td>1</td></tr><tr><td>1,000</td><td>13</td></tr><tr><td>10,000</td><td>686</td></tr><tr><td>100,000</td><td>80554</td></tr></tbody></table><p>很显然，这种暴力的做法对于大一点的数量级就很吃力了，但是我又不想那么快就用链表，有没有哪里是可以优化的呢。</p><h2 id="消除循环"><a href="#消除循环" class="headerlink" title="消除循环"></a>消除循环</h2><p>其实在前面的解法中，耗时操作有这么几个：</p><ul><li><code>findIndex</code> 中不停得对整个 <code>map</code> 进行遍历，即便对于 <code>false</code> 直接跳过，但杯水车薪。</li><li><code>count</code> 中对整个 <code>map</code> 进行遍历才能得到此时数组中 <code>true</code> 的数量。</li><li><code>find</code> 中同样需要对整个 <code>map</code> 进行遍历才能得到剩下的一个 <code>true</code> 的下标。</li></ul><p>其中第一点应该是这种解法的本质，没什么好办法，那么看看后两点。</p><h3 id="消除-count"><a href="#消除-count" class="headerlink" title="消除 count"></a>消除 <code>count</code></h3><p>这个方法想做的事就是每次循环时检查此时数组中 <code>true</code> 的数量是不是只剩一个了，因为这是循环的终结条件。</p><p>那么我们可以引入一个计数器：</p><pre><code class="java">    private static int findIndex(final int N) {        boolean[] map = new boolean[N];        Arrays.fill(map, true);        int walk = 1;         int countDown = N;        for (int index = 0; countDown &gt; 1; index = (index == N - 1) ? 0 : (index + 1)) {            if (! map[index]) continue;            if (walk++ != 3) continue;            walk = 1;            map[index] = false;               countDown -= 1;        }        return find(map);    }</code></pre><p>改成这种做法后，猜猜对于 <strong>100,000</strong> 这个数量级，这个暴力算法需要用时多久呢？</p><p>答案是 <strong>11 ms</strong> 。</p><p>对于 <strong>100,000,000</strong> 这个数量级，这个暴力算法仍只需要 <strong>3165 ms</strong>。</p><p><em>稍稍透露一下，后边的链表解法在这个数量级的成绩是 <strong>7738 ms</strong>，当然可能是我太垃圾了，发挥不出链表的威力 Orz）</em></p><h3 id="消除-find"><a href="#消除-find" class="headerlink" title="消除 find"></a>消除 <code>find</code></h3><p>这个方法要做的是从整个数组中找到唯一的 <code>true</code>  的下标，这同样可以用一个外部变量来消除循环：</p><pre><code class="java">    private static int findIndex(final int N) {        boolean[] map = new boolean[N];        Arrays.fill(map, true);        int walk = 1;         // 记录现在访问到值为 true 的下标        int current = 0;        int countDown = N;        for (int index = 0; countDown &gt; 1; index = (index == N - 1) ? 0 : (index + 1)) {            if (! map[index]) continue;            if (walk++ != 3) {                   // 记录最后一次遇到 true 的位置                current = index;                continue;            }            walk = 1;            map[index] = false;            countDown -= 1;        }         // 人的位置是从 1 开始数的，所以这里要加 1        return current + 1;    }</code></pre><p>但是这个改动对速度的提升效果很小，对于 <strong>100,000,000</strong> 这个数量级，速度仍然在 <strong>3158 ~ 3191 ms</strong> 左右。</p><h1 id="不暴力了，用链表吧"><a href="#不暴力了，用链表吧" class="headerlink" title="不暴力了，用链表吧"></a>不暴力了，用链表吧</h1><p>使用链表可以很方便得体现 <em>退出</em> 这个概念，链表的长度会随着算法的进行而越来越短直至剩下最后一个元素。因为没有 <em>跳过标记为 <code>false</code> 的步骤</em>，理论上会比暴力数组解法要快。</p><pre><code class="java">    static class Node {           // 当前节点的下标，即人的位置        int index;           // 上一个节点        Node prev;         // 下一个节点        Node next;        public Node (int index) {            this.index = index;        }        public Node append(Node next) {            this.next = next;            next.prev = this;            return next;        }         // 需要报号为3的人（当前元素）退出时，从链表中断开并将两边拼接起来        public Node jump() {            Node newNode = this.next;            newNode.prev = this.prev;            newNode.prev.next = newNode;            this.prev = null;            this.next = null;            return newNode;        }        public static int findIndex(final int N) {            Node root = new Node(1);               // 初始化链表并赋值，这个过程对于很大的数量级而言速度肯定是慢过对数组的赋值的，             // 毕竟类的实例化需要开销。因此这段初始化不计入时间            Node current = root;            for (int i = 2; i &lt;= N; i++) {                current = current.append(new Node(i));            }            // 将首尾相连构成循环列表            current = current.append(root);            long mills = System.currentTimeMillis();            int COUNTER = N;            int walk = 1;            while (COUNTER &gt; 1) {                if (walk++ != 3) {                    current = current.next;                } else {                    current = current.jump();                    walk = 1;                    COUNTER -= 1;                }            }            System.out.println(System.currentTimeMillis() - mills);            return current.index;        }    }</code></pre><h1 id="看看两种解法的速度对比"><a href="#看看两种解法的速度对比" class="headerlink" title="看看两种解法的速度对比"></a>看看两种解法的速度对比</h1><table><thead><tr><th>N</th><th>数组暴力法 / ms</th><th>数组暴力法（改进） / ms</th><th>链表法 / ms</th></tr></thead><tbody><tr><td>100</td><td>2</td><td>0</td><td>0</td></tr><tr><td>1,000</td><td>15</td><td>1</td><td>0</td></tr><tr><td>10,000</td><td>673</td><td>5</td><td>1</td></tr><tr><td>100,000</td><td>79998</td><td>10</td><td>3</td></tr><tr><td>1,000,000</td><td>N/A</td><td>38</td><td>64</td></tr><tr><td>10,000,000</td><td>N/A</td><td>309</td><td>718</td></tr><tr><td>100,000,000</td><td>N/A</td><td>3151</td><td>7738</td></tr></tbody></table><p>​    对于 1,000,000 及以上的数量级就没测原数组暴力法了，太慢了…</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到，在百万级别，改进的数组暴力法已经要比链表法快一半了，在亿级要快的更多。</p><p>当然这个速度差异很大程度上是因为随着数量级的加大，链表法所需要的内存开销已经超出一个合理的范围了，随之而来的就是链表的断开重组操作要比 <em>标记</em> 重太多了。</p><p>但是这只是 <strong>想知道最后一个人的位置</strong> 的情况，数组的下标可以做到一定程度的契合，如果情况更复杂了，显然数组就不够用了。</p><p>对于链表法在超大数量级的解法，感觉可以用多线程来做一次整体循环内的截断，只是这样复杂度就上去了，暂时不做了，有兴趣的读者可以自行尝试一下。</p><h1 id="算法的力量"><a href="#算法的力量" class="headerlink" title="算法的力量"></a>算法的力量</h1><pre><code class="java">    public static int josephus(int n) {        int res = 0;        if (n == 0) return 0;        if (n &lt; 3) {            for (int i = 2; i &lt;= n; i++) {                res = (res + 3) % i;            }        } else {            res = josephus(n - n / 3);            if (res &lt; (n % 3)) {                res = res - (n % 3) + n;            } else {                res = res - (n % 3) + (res - (n % 3)) / 2;            }        }        return res;    }    public static void main(String ...args) {        System.out.println(hosephus(1000000000));    }</code></pre><p>这个解法对于一亿这个数量级的运算时间是不到 <strong>0 ms</strong>，来自我的 <strong>ACMer</strong> 同学 ( 打不过正规军啊，跪了</p><p>据我同学所说:</p><blockquote><p>递归层数 log 级别，n 可以达到 1e18 级别，15 ms 内给出答案。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java·变量里存的到底是什么</title>
      <link href="/2018/02/26/Java%C2%B7%E5%8F%98%E9%87%8F%E9%87%8C%E5%AD%98%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <content type="html"><![CDATA[<p>考虑下面这个例子：</p><pre><code class="java">Long l1 = 1L;Long l2 = 2L;Long l3 = 3L;long l4 = 3L;Long l5 = 1 + 2L;System.out.println(l3 == 3);System.out.println(l4 == 3);System.out.println(l3.equals(3));System.out.println(l3.equals(l4));System.out.println(l3.equals(l5));</code></pre><p>输出的结果是</p><pre><code class="text">truetruefalsetruetrue</code></pre><p>相信这个例子很多初学者都犯过迷糊：<code>l3</code>、<code>l4</code> 不都是 <code>3</code> 吗，怎么 <code>l3.equals(3)</code> 是 <code>false</code> 呢。</p><p>这里面有很多点可以讲的，我们一个一个来看：</p><h2 id="Long-和-long"><a href="#Long-和-long" class="headerlink" title="Long 和 long"></a><code>Long</code> 和 <code>long</code></h2><p>在 <code>Java</code> 里只有两种类型: <code>primitive types</code> 原始类型 和 <code>reference types</code> 引用类型。</p><p><strong><code>null</code> 是一种特殊的类型</strong></p><blockquote><p>规范说明：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.1" target="_blank" rel="noopener">4.1. The Kinds of Types and Values</a></p></blockquote><p>原始类型里包括：<code>boolean、byte、short、int、long、char、float、double</code>；<br>引用类型有四种：<code>class、interface、type、array</code> (其中 <code>type</code> 我们平时遇到过的就是泛型 <code>T</code>，详细内容可以查阅规范 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4" target="_blank" rel="noopener">4.4. Type Variables</a>)</p><p>所以这里，<code>long</code> 是原始类型，<code>Long</code> 是引用类型，这很重要，是接下来讨论的基础。</p><h2 id="Boxing-Conversion-和-Unboxing-Conversion"><a href="#Boxing-Conversion-和-Unboxing-Conversion" class="headerlink" title="Boxing Conversion 和 Unboxing Conversion"></a><code>Boxing Conversion</code> 和 <code>Unboxing Conversion</code></h2><p>其实这个就是拆箱装箱，这个知识点应该不陌生吧，就是 <code>Java</code> 会自动帮你把原始数值类型和原始浮点类型转换为对应的引用类型，如 <code>long</code> 转换为 <code>Long</code>。</p><p>举个栗子：</p><pre><code class="java">public void func(Long l) {    System.out.println(l);}func(1L);</code></pre><p>这段代码是可以跑起来的，但是如果调用时是这样的 <code>func(1)</code>，那么就会报错，因为 <code>1</code> 是整数型，它即便自动装箱也是 <code>Integer</code> 而不是 <code>Long</code>。</p><h2 id="Objects，变量里存的是什么"><a href="#Objects，变量里存的是什么" class="headerlink" title="Objects，变量里存的是什么"></a><code>Objects</code>，变量里存的是什么</h2><p>在<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1" target="_blank" rel="noopener">规范</a>中，对于 <code>Obejct</code> 有这么一句话：</p><blockquote><p>An object is a class instance or an array.<br>一个 <code>Object</code> 可以是一个类的实例或者是一个数组 (一个数组其实是一个 <code>Object</code>，不过这是另一个话题了。)<br>The reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.<br>引用值（通常是引用）是指向这些对象的指针和一个特殊的null引用，它不引用任何对象。</p></blockquote><p>有些学过 <code>C++</code> 的或是有 <em>引用</em> 这个概念的其他语言的同学，可能在这里要犯迷糊了：不是说 <code>Java</code> 里没有引用吗，怎么规范里又提到这个词了。</p><pre><code> 注意，C 里面没有引用只有指针，它跟 Java 一样是值传递的。</code></pre><p>其实可以这么不严谨地认为：<code>C++</code> 里的 <em>引用</em> 是动词，<code>Java</code> 里的 <em>引用</em> 是名词。</p><p><code>C++</code> 里的引用是对一个变量定义一个别名：</p><pre><code class="c++">int a = 2, int &amp;ra = a;// a为目标原名称，ra为目标引用名。给ra赋值：ra = 1; 等价于 a = 1;</code></pre><blockquote><p><a href="https://baike.baidu.com/item/C++%E5%BC%95%E7%94%A8/463646?fr=aladdin" target="_blank" rel="noopener">C++ 引用</a></p></blockquote><p><code>Java</code> 里的引用就是一个值，一个指向 <strong>对象</strong> 的值。</p><pre><code class="java">public static void func(String s) {    s = &quot;bar&quot;;}String s1 = &quot;foo&quot;;func(s1);System.out.println(s1); // &quot;foo&quot;</code></pre><p>在这里，<code>s1</code> 的值并不是 <code>foo</code>，而是一个指向 <strong>其字段<code>value</code>值为 <code>[&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</code>的 <code>String</code> 实例</strong> 的引用。</p><p>比如说，再声明一个 <code>String s2 = &quot;foo&quot;;</code>，然后在 <code>func(s1);</code> 处下断点，可以看到：</p><p><img src="/img/bV4kcI" alt="clipboard.png"></p><p>可以看到，<code>String{@xxx}</code> 和 <code>value:byte[]{@xxx}</code> 都是一样的，因为它们就是同一个对象，<code>s1</code> 和 <code>s2</code> 这两个变量的值是 <em>指向了同一个对象(String{@674})<strong>的</strong>引用</em>。</p><p>如果我们在 <code>func(String s)</code> 里打断点，会发现在 <code>func(s1)</code> 的情况下，<code>s</code> 和 <code>s1</code> 的 <strong>引用值</strong> 是一样的。</p><p>因为 <code>Java</code> 是值传递，只不过在引用类型的情况下，传递的这个值，就是 <strong>引用值</strong>。</p><p>当 <code>func</code> 内部对这个 <code>s</code> 进行操作后，我们再来看看<code>func</code>内部断点的情况：</p><pre><code class="java">public static void func(String s) {    s = &quot;bar&quot;;    // 断点处，此时 s 的引用值已经变为 String{@674}    // 即此时的 s 的引用值已经不再是 s1 的引用值，自此它们已经指向的是不同的对象了。}</code></pre><blockquote><p>由于 <code>String</code> 的设计是不可变的，在一个 <code>String</code> 实例上的任何增删操作都会产生一个新的 <code>String</code> 实例，效果与重新为变量设定新的引用值是一样的。</p></blockquote><p>我们再看看一个原始类型的断点情况：</p><pre><code class="java">int i = 0;</code></pre><p><img src="/img/bV4kid" alt="clipboard.png"></p><p>对于原始类型的变量而言，它们的值就是本身。</p><h2 id="和-equals"><a href="#和-equals" class="headerlink" title="==和 equals"></a><code>==</code>和 <code>equals</code></h2><p><code>==</code> 操作符在规范里其实分了三种情况：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1" target="_blank" rel="noopener">15.21.1. Numerical Equality Operators == and !=</a></li><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.2" target="_blank" rel="noopener">15.21.2. Boolean Equality Operators == and !=</a></li><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.3" target="_blank" rel="noopener">15.21.3. Reference Equality Operators == and !=</a></li></ul><p><code>equals</code> 是 <code>Object</code> 的方法，但是任何类都可以覆写这个方法来实现自定义的实例间判断，比如 <code>Long.equals</code> 就改成了这个样子：</p><pre><code class="java">    /**     * Compares this object to the specified object.  The result is     * {@code true} if and only if the argument is not     * {@code null} and is a {@code Long} object that     * contains the same {@code long} value as this object.     *     * @param   obj   the object to compare with.     * @return  {@code true} if the objects are the same;     *          {@code false} otherwise.     */    public boolean equals(Object obj) {        if (obj instanceof Long) {            return value == ((Long)obj).longValue();        }        return false;    }</code></pre><p>也就是说，只要待判定对象不是 <code>Long</code> 或其子类，那么就直接返回 <code>false</code>。</p><p>结合前边讲的 <code>int</code> 在方法调用时会被自动装箱成 <code>Integer</code>（如果参数不显式要求 <code>int</code> 类型），很显然，<code>l3.equals(3)</code> 会直接因为 <code>Integer 3</code> 不是 <code>Long</code> 而返回 <code>false</code>。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java·尝试解析器的总结</title>
      <link href="/2018/02/09/Java%C2%B7%E5%B0%9D%E8%AF%95%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>由于我对写解析器只有 <strong>阅读了几篇文章</strong> 的知识量，因此水平并不是很高，此文权当一次个人总结，无法保证所涉及的知识点、思路完全无误，如有错误，还请各位大佬指正。</p><h2 id="从一个正整数表达式开始"><a href="#从一个正整数表达式开始" class="headerlink" title="从一个正整数表达式开始"></a>从一个正整数表达式开始</h2><p>这篇文章围绕的仅仅是一个 <strong>正整数表达式</strong>，而且它很简单，不会出现括号嵌套等情况，我们的目标只是把</p><pre><code class="text">10 * 5 + 1</code></pre><p>解析为一个 <code>Token</code> 序列，如下：</p><pre><code class="text">[    { type: NUMBER,   value: `10` },    { type: OPERATOR, value: `*`  },    { type: NUMBER,   value: `5`  },    { type: OPERATOR, value: `+`  },    { type: NUMBER,   value: `1`  }]</code></pre><p>我习惯从简单的开始，那么我们先从一个最简单的、只有个位数、没有空格的式子开始:</p><pre><code class="text">1+1</code></pre><h2 id="最简单的思路"><a href="#最简单的思路" class="headerlink" title="最简单的思路"></a>最简单的思路</h2><p>其实词法分析器要做的事本质上很简单：对输入的字符串进行遍历，分割成有意义的 <code>Token</code>。<br>因此，最简单的思路就是一个 <code>for</code> 循环:</p><pre><code class="java">String expression = &quot;1+1&quot;;for (char ch : expression.toCharArray()) {    // 在这里进行处理}</code></pre><p>所以我们定义一个 <code>Scanner</code>，为了后续方便，顺手实现个简单的单例吧：</p><pre><code class="java">public class Scanner {      private static volatile Scanner instance;    public static Scanner getInstance() {          if (Scanner.instance == null) {              synchronized ( Scanner.class ) {                  if (Scanner.instance == null) {                    Scanner.instance = new Scanner();                }            }        }        return Scanner.instance;    }    private String expression;    public Scanner from(String expression) {        this.expression = expression;        return this;    }      public void process() {        for (char ch : expression.toCharArray()) {            // 在这里进行处理        }    }     public static void main(String ... args) {        Scanner scanner = Scanner.getInstance().from(&quot;1+1&quot;);          scanner.process();    }}</code></pre><h2 id="定义-Token-类型"><a href="#定义-Token-类型" class="headerlink" title="定义 Token 类型"></a>定义 <code>Token</code> 类型</h2><p>在当前的 <code>1+1</code> 表达式中，涉及到的 <code>Token</code>  不多，只有数字、操作符，因此用一个枚举类即可表述:</p><pre><code class="java">public enum Type {    INIT,    NUMBER,    OPERATOR,    UNKNOWN;    public static Type of(char ch) {        if (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {            return NUMBER;        }        if (&quot;+-*/&quot;.indexOf(ch) != -1) {            return OPERATOR;        }        return UNKNOWN;    }}</code></pre><p>同时该枚举类承担辨识字符类型的工作：</p><pre><code class="java">Type.of(&#39;1&#39;) // NUMBERType.of(&#39;+&#39;) // OPERATORType.of(&#39;a&#39;) // UNKNOWN</code></pre><h2 id="定义-Token"><a href="#定义-Token" class="headerlink" title="定义 Token"></a>定义 <code>Token</code></h2><pre><code class="java">public class Token {    // 一个 Token 的类型一旦确定，就不可能再改变。    private final Type type;    // 用以存储 Token 的值。    private final StringBuffer value;    public Token(Type type) {        this.type = type;        this.value = new StringBuffer();    }    public void appendValue(char ch) {        this.value.append(ch);    }    public String getValue() {        return this.value.toString();    }    public Type getType() {        return this.type;    }    @Override    public String toString() {        return String.format(&quot;{type: %s, value: `%s`}&quot;,            this.getType().name(),            this.getValue());    }}</code></pre><h2 id="处理-1-1"><a href="#处理-1-1" class="headerlink" title="处理 1+1"></a>处理 <code>1+1</code></h2><pre><code class="java">public class Scanner {      // 省略...        public void process() {        for (char ch : expression.toCharArray()) {            Type type = Type.of(ch);            if (Type.UNKNOWN.equals(type)) {                throw new RuntimeException(String.format(&quot;`%c` 并不属于期望的字符类型&quot;, ch));            }            Token token = new Token(type);            token.appendValue(ch);            System.out.println(token);        }    }     public static void main(String ... args) {        Scanner scanner = new Scanner(&quot;1+1&quot;);          scanner.process();    }}/** 输出 * {type: NUMBER,   value: `1`} * {type: OPERATOR, value: `+`} * {type: NUMBER,   value: `1`} */</code></pre><h2 id="现在来加点难度-10-1"><a href="#现在来加点难度-10-1" class="headerlink" title="现在来加点难度: 10+1"></a>现在来加点难度: <code>10+1</code></h2><p>现在一个数字可能不止一位了，那么我们该怎么办呢？</p><p>使用状态图：</p><pre><code class="text">   ┌-[ 0-9 ]-┐    ┌-[ +|-|*|/ ]-┐   ┌-[ 0-9 ]-┐---(  NUMBER  )--- (  OPERATOR  )---(  NUMBER  )---</code></pre><p>具体的理论这里就不赘述了，有兴趣可以自行查阅相关资料，这里简单说一下怎么用：</p><p>现在我们来列个表，看一下对于 <code>10+1</code>，在状态上有什么变化：</p><table><thead><tr><th>字符</th><th>状态</th><th>Token</th></tr></thead><tbody><tr><td><code>NULL</code></td><td><code>INIT</code></td><td><code>NULL</code></td></tr><tr><td>1</td><td><code>NUMBER</code></td><td>{id: <code>0</code>, type: <code>NUMBER</code>, value: <code>1</code>}</td></tr><tr><td>0</td><td><code>NUMBER</code></td><td>{id: <code>0</code>, type: <code>NUMBER</code>, value: <code>10</code>}</td></tr><tr><td>+</td><td><code>OPERATOR</code></td><td>{id: <code>1</code>, type: <code>OPERATOR</code>, value: <code>+</code>}</td></tr><tr><td>1</td><td><code>NUMBER</code></td><td>{id: <code>2</code>, type: <code>NUMBER</code>, value: <code>1</code>}</td></tr></tbody></table><p>可以看到，在读到字符 <code>1</code> 和 <code>0</code> 时，状态没有发生变化，也就是说它们是一个整体（或是一个整体的一部分）。<br>如果在 <code>0</code> 后面还有其他数字，那么直到引起状态改变的字符出现之前，这些字符就组成了整个 <code>Token</code>。</p><p>同时，我们还发现引入状态图后，有个有意思的事：</p><p>从 初始状态 <code>INIT</code> 开始，我们只允许后边是 <code>NUMBER</code> 类型;<br><code>NUMBER</code> 后边允许 <code>NUMBER</code>、<code>OPERATOR</code> 类型;<br><code>OPERATOR</code> 后边允许 <code>NUMBER</code> 类型。</p><p>除此之外的状态都是不合法的，这也就是有时候解析类的包（比如 <code>fast-json</code>）会看到的 <code>Invalid Character</code> 错误的情况。</p><p>所以我们需要改改代码，同时为 <code>Scanner</code> 添加一个更新状态的方法:</p><pre><code class="java">public class Scanner {    // 省略      private Token token;      public void setToken(Token token) {        this.token = token;    }      public void process() {          // 初始化          this.setToken(new Token(Type.INIT));        for (char ch : expression.toCharArray()) {            Type type = Type.of(ch);            if (Type.UNKNOWN.equals(type)) {                throw new RuntimeException(String.format(&quot;`%c` 并不属于期望的字符类型&quot;, ch));            }            // 根据当前 Token 的类型，选择不同的判断分支            switch (token.getType()) {                case INIT:                    switch (type) {                        // 当前是初始状态，遇到了数字, 切换状态。                        case NUMBER:                            this.setToken(new Token(Type.NUMBER));                            this.token.appendValue(ch);                            break;                        default:                            throw new RuntimeException(String                                                   .format(&quot;Invalid Character: `%c`&quot;, ch));                    }                    break;                case NUMBER:                    switch (type) {                        // 当前是数字状态，遇到了数字，追加字符。                        case NUMBER:                            this.token.appendValue(ch);                            break;                        // 当前是数字状态，遇到了操作符，切换状态。                        case OPERATOR:                            this.setToken(new Token(Type.OPERATOR));                            this.token.appendValue(ch);                            break;                        default:                            throw new RuntimeException(String                                                   .format(&quot;Invalid Character: `%c`&quot;, ch));                    }                    break;                case OPERATOR:                    switch (type) {                        // 当前是操作符状态，遇到了数字，切换状态。                        case NUMBER:                            this.setToken(new Token(Type.NUMBER));                            this.token.appendValue(ch);                            break;                        default:                            throw new RuntimeException(String                                                   .format(&quot;Invalid Character: `%c`&quot;, ch));                    }                    break;            }            System.out.println(token);        }    }}</code></pre><pre><code class="java">/** 输出 * {type: NUMBER,   value: `1`} * {type: NUMBER,   value: `10`} * {type: OPERATOR, value: `+`} * {type: NUMBER,   value: `1`} */</code></pre><h2 id="试着简化一下"><a href="#试着简化一下" class="headerlink" title="试着简化一下"></a>试着简化一下</h2><p>我们刚才用了一个巨大无比的 <code>switch</code> 结构来描述状态图，现在我们由内而外试着简化这个巨无霸。</p><p>###　先从内部开始：</p><pre><code class="java">switch (type) {    // 当前是 ** 状态，遇到了 ** , 执行 ** 操作。    case NUMBER:        // ...        break;    case ...    default:        throw new RuntimeException(String.format(&quot;Invalid Character: `%c`&quot;, ch));}</code></pre><p>其实稍微归纳总结一下就能发现， <code>执行 ** 操作</code> 这部分，总的来说只有两种：</p><pre><code class="text">NewToken    对应着        {            token = new Token(Type.NUMBER);            token.appendValue(ch);        }AppendValue    对应着        {            token.appendValue(ch);        }</code></pre><p>现在我们再引入一个工具来帮助我们简化：表驱动。</p><p>其实从上面的对应关系不难发现，我们可以用 <code>HashMap</code> 来简单模拟一个表，帮助我们减少工作。</p><p>在此之前，我们需要把上述关系中的 <code>{操作}</code> 部分用一个接口来解耦：</p><pre><code class="java">public interface Behavior {    void apply(Token token, Type type, char ch);}</code></pre><p>然后我们来定义一个枚举类 <code>Behaviors</code> 来表示操作类型：</p><pre><code class="java">public enum Behaviors {    NewToken,      AppendValue;      private static final Scanner scanner;    private static final HashMap&lt;Behaviors, Behavior&gt; behaviorMap;    static {          scanner = Scanner.getInstance();        behaviorMap = new HashMap&lt;&gt;();        behaviorMap.put(Behaviors.NewToken, (token, type, ch) -&gt; {            token = new Token(type);            token.appendValue(ch);              scanner.setToken(token);        });        behaviorMap.put(Behaviors.AppendValue, (token, type, ch) -&gt; {            token.appendValue(ch);        });    }    public void apply(Token token, Type type, char ch) {        behaviorMap.get(this)                .apply(token, type, ch);    }}</code></pre><p>那么现在 <em>执行 ** 操作</em> 这部分，现在可以用 <code>HashMap</code> 来表述了：</p><pre><code class="java">// 根据当前 Token 的类型，选择不同的判断分支switch (token.getType()) {    case INIT:        HashMap&lt;Type, Behaviros&gt; behaviorsMap = new HashMap&lt;&gt;();        // 当前是初始状态，遇到了数字, 切换状态。        behaviorsMap.put(Type.NUMBER, Behaviors.NewToken);        break;      case NUMBER:           HashMap&lt;Type, Behaviros&gt; behaviorsMap = new HashMap&lt;&gt;();        // 当前是数字状态，遇到了数字，追加字符。        behaviorsMap.put(Type.NUMBER, Behaviors.AppendValue);        // 当前是数字状态，遇到了操作符，切换状态。        behaviorsMap.put(Type.Operator, Behaviors.NewToken);         break;    case OPERATOR:        HashMap&lt;Type, Behaviros&gt; behaviorsMap = new HashMap&lt;&gt;();        // 当前是操作符状态，遇到了数字，切换状态。        behaviorsMap.put(Type.NUMBER, Behaviors.NewToken);        break;}</code></pre><p>既然是 <code>Java</code> ，那么让我们来让这部分看起来 <code>OO</code> 一些：</p><pre><code class="java">public class BehaviorMap {    private final HashMap&lt;Type, Behaviors&gt; map;      public BehaviorMap() {        this.map = new HashMap();    }      public BehaviorMap at(Type type, Behaviors behaviors) {        this.map.put(type, behaviors);          return this;    }     public BehaviorsTable done() {          return BehaviorsTable.getInstance();    }}</code></pre><p>现在再来看看：</p><pre><code class="java">// 根据当前 Token 的类型，选择不同的判断分支switch (token.getType()) {    case INIT:        BehaviorMap map = new BehaviorMap();        map               // 当前是初始状态，遇到了数字, 切换状态。              .at(Type.NUMBER, Behaviors.NewToken);        break;      case NUMBER:           BehaviorMap map = new BehaviorMap();        map              // 当前是数字状态，遇到了数字，追加字符。             .at(Type.NUMBER, Behaviors.AppendValue);            // 当前是数字状态，遇到了操作符，切换状态。            .at(Type.Operator, Behaviors.NewToken);         break;    case OPERATOR:        BehaviorMap map = new BehaviorMap();        map              // 当前是操作符状态，遇到了数字，切换状态。              .at(Type.NUMBER, Behaviors.NewToken);        break;}</code></pre><h3 id="简化外部"><a href="#简化外部" class="headerlink" title="简化外部"></a>简化外部</h3><p>现在我们可以看到表驱动对于消除判断分支的威力了，那么我们可以用同样的方法将外部 <code>switch</code> 也消除掉：</p><pre><code class="java">public class BehaviorsTable {    private static volatile BehaviorsTable instance;    public static BehaviorsTable getInstance() {        if (BehaviorsTable.instance == null) {            synchronized ( BehaviorsTable.class ) {                if (BehaviorsTable.instance == null) {                    BehaviorsTable.instance = new BehaviorsTable();                }            }        }        return BehaviorsTable.instance;    }    private final HashMap&lt;Type, BehaviorMap&gt; map;    public BehaviorsTable () {        this.map = new HashMap&lt;&gt;();    }    public BehaviorMap register(Type type) {        BehaviorMap behaviorMap = new BehaviorMap();        this.map.put(type, behaviorMap);        return behaviorMap;    }}</code></pre><p>现在整个巨大的 <code>switch</code> 结构我们就可以简化为:</p><pre><code class="java">BehaviorsTable    .getInstance()    .register(Type.INIT)        .at(Type.NUMBER, Behaviors.NewToken)        .done()    .register(Type.NUMBER)          .at(Type.NUMBER, Behaviors.AppendValue)          .at(Type.OPERATOR, Behaviors.NewToken)          .done()      .register(Type.OPERATOR)          .at(Type.NUMBER, Behaviors.NewToken)          .done();</code></pre><p>现在 <code>process</code> 方法我们就可以简化为:</p><pre><code class="java">public void process() {    this.setToken(new Token(Type.INIT));    for (char ch : expression.toCharArray()) {        Type type = Type.of(ch);        if (Type.UNKNOWN.equals(type)) {            throw new RuntimeException(String.format(&quot;`%c` 并不属于期望的字符类型&quot;, ch));        }        BehaviorsTable            .getInstance()               // 根据当前 Token 类型获取对应的处理对策            .get(this.token.getType())                  // 获取当前字符所属的处理行为                .is(type)                .apply(type, ch);        System.out.println(token);    }}</code></pre><blockquote><p> 我们在源码里做了一些改动，请参考文章底部全部代码。</p></blockquote><h2 id="让我们测试一下"><a href="#让我们测试一下" class="headerlink" title="让我们测试一下"></a>让我们测试一下</h2><pre><code class="java">public static void main(String ... args) {    Scanner scanner = Scanner.getInstance();    scanner.from(&quot;10+1&quot;).process();      /**       * {type: NUMBER, value: `1`}       * {type: NUMBER, value: `10`}       * {type: NUMBER, value: `+`}       * {type: NUMBER, value: `1`}       */      scanner.from(&quot;10 +1&quot;).process();       /**       * {type: NUMBER, value: `1`}       * {type: NUMBER, value: `10`}       * Exception in thread &quot;main&quot; java.lang.RuntimeException: ` ` 并不属于期望的字符类型       */      scanner.from(&quot;10++1&quot;).process();      /**       * {type: NUMBER, value: `1`}       * {type: NUMBER, value: `10`}       * {type: OPERATOR, value: `+`}    * Exception in thread &quot;main&quot; java.lang.RuntimeException: Invalid Character: `+` for Token `OPERATOR`       */}</code></pre><p>现在看起来一切正常，但是别忘了 <code>Scanner</code> 的工作是将输入的字符串分割为 <code>Token</code> 序列，因此我们需要让 <code>process</code> 方法返回处理后的 <code>LinkedList&lt;Token&gt;</code> 序列。</p><p>为此我们需要将每次新生成的 <code>Token</code> 保存下来：</p><pre><code class="java">public class Scanner {    private LinkedList&lt;Token&gt; tokens;      private Token token;      public void addToken(Token token) {        this.token = token;          this.tokens.add(token);    }       public LinkedList&lt;Token&gt; process() {        this.setToken(new Token(Type.INIT));        for (char ch : expression.toCharArray()) {            Type type = Type.of(ch);            if (Type.UNKNOWN.equals(type)) {                throw new RuntimeException(String.format(&quot;`%c` 并不属于期望的字符类型&quot;, ch));            }            BehaviorsTable                    .getInstance()                    .get(this.token.getType())                    .is(type)                    .apply(type, ch);        }        return this.tokens;    }       public static void main(String ... args) {        Scanner scanner = Scanner.getInstance().from(&quot;10*5+1&quot;);          LinkedList&lt;Token&gt; tokens = scanner.process();          for (Token token : tokens) {              System.out.println(token);        }    }}</code></pre><p>记得将 <code>Behaviors</code> 初始化部分中 <code>NewToken</code> 里的行为修改一下：</p><pre><code class="java">        behaviorMap.put(Behaviors.NewToken, (token, type, ch) -&gt; {            token = new Token(type);            token.appendValue(ch);              //scanner.setToken(token);            scanner.addToken(token);        });</code></pre><p>现在再看看结果：</p><pre><code class="text">{type: NUMBER, value: `10`}{type: OPERATOR, value: `*`}{type: NUMBER, value: `5`}{type: OPERATOR, value: `+`}{type: NUMBER, value: `1`}</code></pre><p>看起来一切都如我们所愿！现在离最初的目标只剩下空格的处理了，得益于我们抽象了行为 <code>Behaviors</code>，我们只需要在 <code>Type</code> 中注册空格，然后为 <code>BehaviorsTable</code> 注册各种类型下对空格的处理就行了：</p><pre><code class="java">public enum Type {    SPACE;      public Tpye of(char ch) {        if (&#39; &#39; == ch) return SPACE;    }}public enum Behaviors {    Continue;      static {        behaviorMap              .put(Behaviors.Continue, (token, type, ch) -&gt; {                // 留空就行了            })    }}public class Scanner {       static {        BehaviorsTable                .getInstance()                .register(Type.INIT)                    .at(Type.NUMBER, Behaviors.NewToken)                       .at(Type.SPACE, Behaviors.Continue)                    .done()                .register(Type.NUMBER)                    .at(Type.NUMBER, Behaviors.AppendValue)                    .at(Type.OPERATOR, Behaviors.NewToken)                       .at(Type.SPACE, Behaviors.Continue)                    .done()                .register(Type.OPERATOR)                    .at(Type.NUMBER, Behaviors.NewToken)                       .at(Type.SPACE, Behaviors.Continue)                    .done();    }}</code></pre><h2 id="还缺什么呢"><a href="#还缺什么呢" class="headerlink" title="还缺什么呢"></a>还缺什么呢</h2><p>我们现在完成的扫描器实际上无法识别出 <code>1 1 + 0</code> 是个错误的表达式，它会解析出如下序列：</p><pre><code class="text">{type: NUMBER, value: 11}{type: OPERATOR, value: +}{type: NUMBER, value: 0}</code></pre><p>我个人希望这部分工作往上层放，由消化 <code>Token</code> 序列的调用者通过模式匹配的方式去验证，不过这样的话，<code>Type.SPACE</code> 的处理就不能随意 <code>Continue</code> 了，有兴趣的话看官可以自行尝试一下 : P</p><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><p>一个小尝试，就不传 Github 了，直接放这儿吧 （其实就是懒…</p><h3 id="Scanner-java"><a href="#Scanner-java" class="headerlink" title="Scanner.java"></a>Scanner.java</h3><pre><code class="java">public class Scanner {   private static volatile Scanner instance;   public static Scanner getInstance() {      if (Scanner.instance == null) {         synchronized ( Scanner.class ) {            if (Scanner.instance == null) {               Scanner.instance = new Scanner();            }         }      }      return Scanner.instance;   }   static {     // 注册行为表      BehaviorsTable            .getInstance()            // 注册 INIT 状态的行为表            .register(Type.INIT)               .at(Type.NUMBER, Behaviors.NewToken)               .at(Type.SPACE, Behaviors.Continue)               .done()            .register(Type.NUMBER)               .at(Type.NUMBER, Behaviors.AppendValue)               .at(Type.OPERATOR, Behaviors.NewToken)               .at(Type.SPACE, Behaviors.Continue)               .done()            .register(Type.OPERATOR)               .at(Type.NUMBER, Behaviors.NewToken)               .at(Type.SPACE, Behaviors.Continue)               .done();   }   private String expression;   private LinkedList&lt;Token&gt; tokens;   private Token token;   public Scanner from(String expression) {      this.expression = expression;      this.tokens = new LinkedList&lt;&gt;();      return this;   }   public void setToken(Token token) {      this.token = token;   }   public Token getToken ( ) {      return token;   }   public LinkedList&lt;Token&gt; process() {      this.setToken(new Token(Type.INIT));      for (char ch : expression.toCharArray()) {         Type type = Type.of(ch);         if (Type.UNKNOWN.equals(type)) {            throw new RuntimeException(String.format(&quot;`%c` 并不属于期望的字符类型&quot;, ch));         }         BehaviorsTable               .getInstance()                   // 获取当前 Token 类型所适用的行为表               .get(this.token.getType())                       // 获取当前字符所适用的行为                       .is(type)                       .apply(type, ch);      }      return this.tokens;    }   public void addToken(Token token) {     // 更新一下当前 Token      this.token = token;      this.tokens.add(token);   }   public static void main(String ... args) {        Scanner scanner = Scanner.getInstance().from(&quot;10 * 5+1&quot;);       LinkedList&lt;Token&gt; tokens = scanner.process();       for (Token token : tokens) {          System.out.println(token);      }    }}</code></pre><h3 id="Type-java"><a href="#Type-java" class="headerlink" title="Type.java"></a>Type.java</h3><pre><code class="java">// Token 类型枚举public enum Type {    INIT,        // 初始化时使用    SPACE,        // 空格    NUMBER,        // 数字    OPERATOR,    // 操作符    UNKNOWN;    // 未知类型    public static Type of(char ch) {        if (&#39; &#39; == ch) {            return SPACE;        }        if (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {            return NUMBER;        }        if (&quot;+-*/&quot;.indexOf(ch) != -1) {            return OPERATOR;        }        return UNKNOWN;    }}</code></pre><h3 id="Token-java"><a href="#Token-java" class="headerlink" title="Token.java"></a>Token.java</h3><pre><code class="java">public class Token {    // 一个 Token 的类型一旦确定，就不可能再改变。    private final Type type;    // 用以存储 Token 的值。    private final StringBuffer value;    public Token(Type type) {        this.type = type;        this.value = new StringBuffer();    }      // 向 value 中追加字符    public void appendValue(char ch) {        this.value.append(ch);    }    public String getValue() {        return this.value.toString();    }    public Type getType() {        return this.type;    }    @Override    public String toString() {        return String.format(&quot;{type: %s, value: `%s`}&quot;,            this.getType().name(),            this.getValue());    }}</code></pre><h3 id="Behavior-java"><a href="#Behavior-java" class="headerlink" title="Behavior.java"></a>Behavior.java</h3><pre><code class="java">public interface Behavior {    /**     * 将行为抽象出来     * @param token 当前的 token     * @param type 读入字符的类型     * @param ch 读入的字符     */    void apply(Token token, Type type, char ch);}</code></pre><h3 id="Behaviors-java"><a href="#Behaviors-java" class="headerlink" title="Behaviors.java"></a>Behaviors.java</h3><pre><code class="java">// 预设行为public enum Behaviors {   NewToken,        // 新建一个指定类型的 Token, 将当前字符保存到新 Token   AppendValue,        // 将当前字符追加到当前 Token 的值中   Continue,        // 跳过当前字符   InvalidCharacter; // 当前 Token 类型所不期望的字符类型，会抛出一个异常      // 持有一个引用就不用老是调用 getInstance()。   private static final Scanner scanner;      // 为预设行为指定行为内容   private static final HashMap&lt;Behaviors, Behavior&gt; behaviorMap;   static {      scanner = Scanner.getInstance();      behaviorMap = new HashMap&lt;&gt;();     // 指定 NewToken，行为逻辑参见枚举值说明      behaviorMap.put(Behaviors.NewToken, (token, type, ch) -&gt; {         token = new Token(type);         token.appendValue(ch);         scanner.addToken(token);      });     // 指定 AppendValue，行为逻辑参见枚举值说明      behaviorMap.put(Behaviors.AppendValue, (token, type, ch) -&gt; {         token.appendValue(ch);      });     // 指定 Continue，行为逻辑参见枚举值说明      behaviorMap.put(Behaviors.Continue, (token, type, ch) -&gt; {});     // 指定 InvalidCharacter，行为逻辑参见枚举值说明      behaviorMap.put(Behaviors.InvalidCharacter, (token, type, ch) -&gt; {         throw new RuntimeException(String                                    .format(&quot;Invalid Character: `%c` for Token `%s`&quot;,                                            ch, token.getType().name()));      });   }   public void apply(Type type, char ch) {     // 获取预设行为      behaviorMap.get(this)            // 向行为中传递当前 Token, 当前字符类型，当前字符            .apply(scanner.getToken(), type, ch);   }}</code></pre><h3 id="BehaviorsMap-java"><a href="#BehaviorsMap-java" class="headerlink" title="BehaviorsMap.java"></a>BehaviorsMap.java</h3><pre><code class="java">// 保存某一字符类需要执行何种预设行为的映射关系public class BehaviorsMap {    private final HashMap&lt;Type, Behaviors&gt; map;   public BehaviorsMap() {        this.map = new HashMap();    }    /**     * 注册指定类型所需的预设行为     * @param type 指定类型     * @param behaviors 指定所需的预设行为     */   public BehaviorsMap at(Type type, Behaviors behaviors) {        this.map.put(type, behaviors);       return this;    }  // 注册完后回退操作域到 BehaviorsTable    public BehaviorsTable done() {      return BehaviorsTable.getInstance();   }  // 获取指定类型的预设行为   public Behaviors is (Type type) {      Behaviors behaviors = this.map.get(type);      if (behaviors == null) {        // 如果没有注册，那么使用 InvalidCharacter 预设行为，因为出现了非预期的字符类型         behaviors = Behaviors.InvalidCharacter;      }      return behaviors;   }}</code></pre><h3 id="BehaviorsTable-java"><a href="#BehaviorsTable-java" class="headerlink" title="BehaviorsTable.java"></a>BehaviorsTable.java</h3><pre><code class="java">// 行为表public class BehaviorsTable {    private static volatile BehaviorsTable instance;    public static BehaviorsTable getInstance() {        if (BehaviorsTable.instance == null) {            synchronized ( BehaviorsTable.class ) {                if (BehaviorsTable.instance == null) {                    BehaviorsTable.instance = new BehaviorsTable();                }            }        }        return BehaviorsTable.instance;    }    private final HashMap&lt;Type, BehaviorMap&gt; map;    public BehaviorsTable () {        this.map = new HashMap&lt;&gt;();    }      // 注册指定当前类型，返回一个空的 BehaviorsMap 来注册预设行为    public BehaviorsMap register(Type type) {        BehaviorsMap behaviorsMap = new BehaviorsMap();        this.map.put(type, behaviorsMap);        return behaviorsMap;    }   // 获取指定当前类型的 BehaviorsMap    public BehaviorsMap get(Type type) {        return this.map.get(type);    }}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法·JavaScript·电话号码分身(小米2017秋招真题)</title>
      <link href="/2017/09/18/%E7%AE%97%E6%B3%95%C2%B7JavaScript%C2%B7%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%88%86%E8%BA%AB-%E5%B0%8F%E7%B1%B32017%E7%A7%8B%E6%8B%9B%E7%9C%9F%E9%A2%98/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>题目描述</strong></p></blockquote><blockquote><p>继MIUI8推出手机分身功能，MIUI计划推出一个电话号码分身得功能：首先将电话号码中的每个数字加上8取个位，然后使用对应得大写字母代替 (“ZERO”, “ONE”, “TWO”, “THREE”, “FOUR”, “FIVE”, “SIX”, “SEVEN”, “EIGHT”, “NINE”), 然后随机打乱这些字母，所生成得字符串即为电话号码对应得分身。</p></blockquote><blockquote><p>例子:<br>输入 =&gt; 输出<br>EIGHT =&gt; 0<br>ZEROTWOONE =&gt; 234<br>OHWETENRTEO =&gt; 345<br>OHEWTIEGTHENRTEO =&gt; 0345</p></blockquote><p>这道题是输入一个字符串，映射到一个数字串。<br>映射题我的习惯是先尝试用字典的方式做，那么接下来开始做这道题：</p><p>10个数字与其英文单词一一对应，那么这些词能不能做些文章呢？</p><p>我们可以发现，在这十个数字的英文单词中，字符 <code>Z</code> 只存在于 <code>ZERO</code>，<code>W</code> 只存在于 <code>TWO</code>，以此类推。<br>所以现在一旦在字符串中发现 <code>Z</code>，我们就可以说存在 <code>0</code>。<br>我们在这里把 <code>Z</code> 称作 <code>特征字符</code>, <code>ZERO</code> 称作 <code>字符值</code>, <code>0</code> 称为 <code>数字值</code><br>那么，我们可以得到一组映射:</p><pre><code class="javascript">{    Z: [&#39;ZERO&#39;, 0],    W: [&#39;TWO&#39;, 2],    U: [&#39;FOUR&#39;, 4],    X: [&#39;SIX&#39;, 6],    G: [&#39;EIGHT&#39;, 8]}</code></pre><p>因此<code>0, 2, 4, 6, 8</code>已经处理好了，现在还剩下 <code>1, 3, 5, 7, 9</code>。<br>仔细分析可以发现，字符<code>O</code>在这五个数字的英文中，只存在于<code>ONE</code>；字符<code>F</code>只存在于<code>FIVE</code>中，以此类推。<br>那么，我们又可以得到一组映射：</p><pre><code class="javascript">{    O: [&#39;ONE&#39;, 1],    T: [&#39;THREE&#39;, 3],    F: [&#39;FIVE&#39;, 5],    S: [&#39;SEVEN&#39;, 7]}</code></pre><p>为什么这里没有<code>9</code>的映射呢？因为 <code>NINE</code>中<code>N, I, E</code>在 <code>1, 3, 5, 7</code>中都有出现，这里我们就先空着。</p><blockquote><p><strong>注意</strong><br><strong>这里的两个映射关系是不可以合并的，想想为什么？</strong></p></blockquote><p>那么这些映射关系有什么用呢？这里就要用到字典(dict)啦。<br>我们可以把输入的字符串，转换为一个字典结构，<code>key</code> 是字符, <code>value</code> 是这个字符在整个字符串中出现的次数。</p><p>例如：</p><pre><code class="javascript">&quot;OHEWTIEGTHENRTEO&quot;var dict = {    E: 4,    T: 3,    O: 2,    H: 2,    I: 1,    G: 1,    W: 1,    N: 1,    R: 1}</code></pre><p>然后我们遍历这个字典:</p><pre><code class="javascript">[{    Z: [&#39;ZERO&#39;, 0],    W: [&#39;TWO&#39;, 2],    U: [&#39;FOUR&#39;, 4],    X: [&#39;SIX&#39;, 6],    G: [&#39;EIGHT&#39;, 8]},{    O: [&#39;ONE&#39;, 1],    T: [&#39;THREE&#39;, 3],    F: [&#39;FIVE&#39;, 5],    S: [&#39;SEVEN&#39;, 7]}].map(map =&gt; {    Object.keys(dict).map(key =&gt; {        /** 检查当前字符是否在映射表中         * 在的话检查字典中当前字符的数量是否仍然大于0         */        map[key] &amp;&amp; dict[key] &gt; 0 &amp;&amp;        /**         * 把映射关系中的字面值取出并拆解为一个字符数组，         * 遍历这个字符数组，将字典中该字符的计数减去1，即消化了这个字面值         */        map[key][0].split(&#39;&#39;).map(char =&gt; dict[char] -= 1) &amp;&amp;        // 把消化的数字值打出来        console.log(map[key][1])    })})/** * 2 * 8 * 1 * 3 */</code></pre><p>可是题目说明 <code>OHEWTIEGTHENRTEO</code> 的输出值应该是 <code>0345</code>呀，哪里出错了呢?</p><p>注意题目中的一句话</p><blockquote><p>首先将电话号码中的每个数字加上8取个位<br>也就是说，我们打出来的值还需要对这个 <code>加8取个位</code> 进行逆向。<br>有几种方法，一是在打印时对 <code>map[key][1]</code> 进行处理:</p><pre><code class="javascript">num =&gt; num - 8 &gt;= 0 ? num - 8 : num + 2</code></pre></blockquote><p>或者，我这里用了偷懒的办法，还记得我们映射表中有个数字值吗？我人工替换了 ：P</p><pre><code class="javascript">[{    Z: [&#39;ZERO&#39;, 2],    W: [&#39;TWO&#39;, 4],    U: [&#39;FOUR&#39;, 6],    X: [&#39;SIX&#39;, 8],    G: [&#39;EIGHT&#39;, 0]},{    O: [&#39;ONE&#39;, 3],    T: [&#39;THREE&#39;, 5],    F: [&#39;FIVE&#39;, 7],    S: [&#39;SEVEN&#39;, 9}].map(map =&gt; {    Object.keys(dict).map(key =&gt; {        map[key] &amp;&amp; dict[key] &gt; 0 &amp;&amp;        map[key][0].split(&#39;&#39;).map(char =&gt; dict[char] -= 1) &amp;&amp;        console.log(map[key][1])    })})/** * 4 * 0 * 3 * 5 */</code></pre><p>那么现在只需要把输出值进行一下正序排序即可：</p><pre><code class="javascript">var output = [];[{ Z: [&#39;ZERO&#39;, 2], W: [&#39;TWO&#39;, 4], U: [&#39;FOUR&#39;, 6], X: [&#39;SIX&#39;, 8], G: [&#39;EIGHT&#39;, 0]},{ O: [&#39;ONE&#39;, 3], T: [&#39;THREE&#39;, 5], F: [&#39;FIVE&#39;, 7], S: [&#39;SEVEN&#39;, 9}].map(map =&gt; {    Object.keys(dict).map(key =&gt; {        map[key] &amp;&amp; dict[key] &gt; 0 &amp;&amp;        map[key][0].split(&#39;&#39;).map(char =&gt; dict[char] -= 1) &amp;&amp;        output.push(map[key][1])    })})/*  * 还记得我们把 9 的处理留空了吗？现在要补上啦~ * 9 的英文 NINE 你只需要随意检查前边过滤后的字典是否还存在 N I E 任意一个字符即可 * 我选择的是判断 E * 输入的9对应的输出应该是1，还记得为什么吗？ *///if (dict[&#39;E&#39;] &amp;&amp; dict[&#39;E&#39;] &gt; 0) output.push(1)/** * 2017.09.19 08:36 更新： * 之前只判断了是否还存在9，但是忘了多个9同时存在的情况，那么需要做如下改进： */ dist[&#39;E&#39;] &amp;&amp; // 检查是否还存在特征字符 E，在经过前面的映射关系过滤后，还剩下几个E，就还有几个9 (output = output.concat(Array(dist[&#39;E&#39;]).fill(1))) //纯js技巧，快速生成指定大小的数组并填充一个值output.sort()console.log(output) // 0 3 4 5</code></pre><p>虽然说本文标题有个 <code>[算法]</code> 前缀，不过这个写法完全没考虑什么复杂度之类的东西 ORZ</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java·通过反射动态修改注解的属性值</title>
      <link href="/2017/09/17/Java%C2%B7%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/"/>
      <content type="html"><![CDATA[<p>昨晚在 <em>SegmentFault</em> 看到一条<a href="#https://segmentfault.com/q/1010000010773372">问题</a>，大意是楼主希望可以动态得建立多个 <em>Spring</em> 的定时任务。</p><p>这个题目我并不是很熟悉，不过根据题目描述和查阅相关 <em>Spring 创建定时任务</em> 的资料，发现这也许涉及到通过Java代码动态修改注解的属性值。</p><p>今天尝试了一番，发现通过反射来动态修改注解的属性值是可以做到的：</p><p>众所周知，<code>java/lang/reflect</code> 这个包下面都是Java的反射类和工具。</p><p><code>Annotation</code> 注解，也是位于这个包里的。注解自从Java 5.0版本引入后，就成为了Java平台中非常重要的一部分，常见的如 <code>@Override</code>、 <code>@Deprecated</code>。</p><p>关于注解更详细的信息和使用方法，网上已经有很多资料，这里就不再赘述了。</p><p>一个注解通过 <code>@Retention</code> 指定其生命周期，本文所讨论的动态修改注解属性值，建立在 <code>@Retention(RetentionPolicy.RUNTIM)</code> 这种情况。毕竟这种注解才能在运行时(runtime)通过反射机制进行操作。</p><p>那么现在我们定义一个 <code>@Foo</code> 注解，它有一个类型为 <code>String</code> 的 <code>value</code> 属性，该注解应用再<code>Field</code>上:</p><pre><code class="java">@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Foo {    String value();}</code></pre><p>再定义一个普通的Java对象 <code>Bar</code>，它有一个私有的<code>String</code>属性 <code>val</code>，并为它设置属性值为<code>&quot;fff&quot;</code> 的 <code>@Foo</code> 注解:</p><pre><code class="java">public class Bar {    @Foo (&quot;fff&quot;)    private String val;}</code></pre><p>接下来在 <code>main</code> 方法中我们来尝试修改 <code>Bar.val</code> 上的 <code>@Foo</code>注解的属性值为 <code>&quot;ddd&quot;</code>。</p><p>先是正常的获取注解属性值:</p><pre><code class="java">public class Main {    public static void main(String ...args) throws NoSuchFieldException {        //获取Bar实例        Bar bar = new Bar();        //获取Bar的val字段        Field field = Bar.class.getDeclaredField(&quot;val&quot;);        //获取val字段上的Foo注解实例        Foo foo = field.getAnnotation(Foo.class);        //获取Foo注解实例的 value 属性值        String value = foo.value();        //打印该值        System.out.println(value); // fff    }}</code></pre><p>首先，我们要知道注解的值是存在哪里的。</p><p>在 <code>String value = foo.value();</code> 处下断点，我们跑一下可以发现：</p><p><img src="https://sfault-image.b0.upaiyun.com/586/692/586692790-59bf18be2b22d_articlex" alt="clipboard.png"></p><p>当前栈中有这么几个变量，不过其中有一点很特别：<code>foo</code>，其实是个<code>Proxy</code>实例。</p><p><code>Proxy</code>也是 <code>java/lang/reflect</code>下的东西，它的作用是为一个Java类生成一个代理，就像这样：</p><pre><code class="java">public interface A {    String func1();}public class B implements A {    @Override    public String func1() { //do something ... }    public String func2() { //do something ... };}public static void main(String ...args) {    B bInstance = new B();    B bProxy = Proxy.newProxyInstance(        // B 类的类加载器        B.class.getClassLoader(),         // B 类所实现的接口。        // 如果你想拦截B类的某个方法，必须让这个方法在某个接口中声明并让B类实现该接口        B.class.getInterfaces(),         // 调用处理器，任何对 B类 所实现的接口方法的调用都会触发此处理器        new InvocationHandler() {             @Override            public Object invoke (                    // 这个是代理的实例，method.invoke时不能使用这个，否则会死循环                    Object proxy,                     // 触发的接口方法                   Method method,                    // 此次调用该方法的参数                    Object[] args) throws Throwable {                System.out.println(String.format(&quot;调用 %s 之前&quot;, method.getName()));                /**                 * 这里必须使用B类的某个具体实现类的实例，因为触发时这里的method只是一个接口方法的引用，                 * 也就是说它是空的，你需要为它指定具有逻辑的上下文(bInstance)。                 */                Object obj = method.invoke(bInstance, args);                 System.out.println(String.format(&quot;调用 %s 之后&quot;, method.getName()));                return obj; //返回调用结果            }        }    );}</code></pre><p>这样你就可以拦截这个Java类的某个方法调用，但是你只能拦截到 <code>func1</code>的调用，想想为什么？</p><p>那么注意了：</p><p><code>ClassLoader</code> 这是个<code>class</code>就会有，注解也不例外。那么注解和<code>interfaces</code>有什么关系?</p><p>注解本质上就是一个接口，它的实质定义为: <code>interface SomeAnnotation extends Annotation</code>。<br>这个 <code>Annotation</code> 接口位于 <code>java/lang/annotation</code> 包，它的注释中第一句话就是 <code>The common interface extended by all annotation types.</code></p><p>如此说来，<code>Foo</code> 注解本身只是个接口，这就意味着它没有任何代码逻辑，那么它的 <code>value</code> 属性究竟是存在哪里的呢？</p><p>展开 <code>foo</code> 可以发现：</p><p><img src="https://sfault-image.b0.upaiyun.com/394/511/3945110165-59bf1caa159d8_articlex" alt="clipboard.png"></p><p>这个 <code>Proxy</code> 实例持有一个 <code>AnnotationInvocationHandler</code>，还记得之前提到过如何创建一个 <code>Proxy</code> 实例么? 第三个参数就是一个 <code>InvocationHandler</code>。<br>看名字这个<code>handler</code>即是<code>Annotation</code>所特有的，我们看一下它的代码：</p><pre><code class="java">class AnnotationInvocationHandler implements InvocationHandler, Serializable {    private final Class&lt;? extends Annotation&gt; type;    private final Map&lt;String, Object&gt; memberValues;    private transient volatile Method[] memberMethods = null;    /* 后续无关代码就省略了，想看的话可以查看      * sun/reflect/annotation/AnnotationInvocationHandler     */}</code></pre><p>我们一眼就可以看到一个有意思的名字: <code>memberValues</code>，这是一个Map，而断点中可以看到这是一个 <code>LinknedHashMap</code>，<code>key</code>为注解的属性名称，<code>value</code>即为注解的属性值。</p><p>现在我们找到了注解的属性值存在哪里了，那么接下来的事就好办了：</p><pre><code class="java">public class Main {    public static void main(String ...args) throws NoSuchFieldException, IllegalAccessException {        //获取Bar实例        Bar bar = new Bar();        //获取Bar的val字段        Field field = Bar.class.getDeclaredField(&quot;val&quot;);        //获取val字段上的Foo注解实例        Foo foo = field.getAnnotation(Foo.class);        //获取 foo 这个代理实例所持有的 InvocationHandler        InvocationHandler h = Proxy.getInvocationHandler(foo);        // 获取 AnnotationInvocationHandler 的 memberValues 字段        Field hField = h.getClass().getDeclaredField(&quot;memberValues&quot;);        // 因为这个字段事 private final 修饰，所以要打开权限        hField.setAccessible(true);        // 获取 memberValues        Map memberValues = (Map) hField.get(h);        // 修改 value 属性值        memberValues.put(&quot;value&quot;, &quot;ddd&quot;);        // 获取 foo 的 value 属性值        String value = foo.value();        System.out.println(value); // ddd    }}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
